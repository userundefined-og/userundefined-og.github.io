
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
   <title>Categories on Blog of the Dad</title>
   <link>https://blog.dawnofthe.dad/categories/</link>
   <description>Recent content in Categories on Blog of the Dad</description>
   <generator>Hugo -- gohugo.io</generator>
   <language>en-us</language>
   
       <atom:link href="https://blog.dawnofthe.dad/categories/index.xml" rel="self" type="application/rss+xml" />
   
   
     <item>
       <title>Search Algo in Go</title>
       <link>https://blog.dawnofthe.dad/posts/search-algo-in-go/</link>
       <pubDate>Sun, 03 Sep 2023 10:24:10 -0700</pubDate>
       
       <guid>https://blog.dawnofthe.dad/posts/search-algo-in-go/</guid>
       <description>&lt;p&gt;My previous couple of posts talked about &lt;a href=&#34;https://blog.dawnofthe.dad/posts/solver-intro/&#34;&gt;what the solver does (solves CSPs)&lt;/a&gt;, &lt;a href=&#34;https://blog.dawnofthe.dad/posts/solver-basics/&#34;&gt;how to model a problem as a CSP, and how the search tree is built&lt;/a&gt; as the solver searches for a solution. In this post I will expand on the details of search by outlining the key data structures and bits of code. The backend is written in &lt;a href=&#34;https://go.dev&#34;&gt;Go lang&lt;/a&gt;, and so are all of the code snippets here.&lt;/p&gt;&lt;h2 id=&#34;nodes-in-the-search-tree&#34;&gt;Nodes in the search tree&lt;/h2&gt;&lt;p&gt;We&amp;rsquo;ll be building a search tree, which is composed of nodes. We&amp;rsquo;ll also need to track a couple of things as we build the search tree. Here they are:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;nodeState&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; (&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;freshNode&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;nodeState&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;iota&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;solutionFound&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;assignmentTried&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;unassignmentTried&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;decision&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;variable&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;model&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Variable&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// When true it means variable = value, when false it means variable != value.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;valueAssigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// nil at root&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;       &lt;span style=&#34;color:#a6e22e&#34;&gt;nodeState&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;decision&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;decision&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;node&lt;/code&gt; struct above lets us:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Keep track of the node&amp;rsquo;s &lt;code&gt;parent&lt;/code&gt;, so we can easily go back up the tree when backtracking,&lt;/li&gt;&lt;li&gt;Keep track of the &lt;code&gt;nodeState&lt;/code&gt;, which we&amp;rsquo;ll use to tell us what to do when we visit or revisit a node,&lt;/li&gt;&lt;li&gt;Keep track of the &lt;code&gt;decision&lt;/code&gt; we made at this node, which we can use to evaluate constraints, and, when all variables are assigned, to tell us what the full solution is, by walking backwards up the tree and collapsing all the decisions that led to the solution into a full assignment of values to variables.&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;building-the-search-tree&#34;&gt;Building the search tree&lt;/h2&gt;&lt;p&gt;My code has two key functions: &lt;code&gt;Run()&lt;/code&gt;, which is the top-level function called by external clients, like the web server, and &lt;code&gt;step()&lt;/code&gt;, which is a single step in the search tree where we look at the current &lt;code&gt;node.state&lt;/code&gt; and decide what to do next. Here they are, along with the &lt;code&gt;Search&lt;/code&gt; struct that they belong to:&lt;/p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-golang&#34; data-lang=&#34;golang&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Search&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Search&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Run&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;done&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;solution&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;step&lt;/span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;done&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solution&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Search&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;step&lt;/span&gt;() (&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt;) {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;freshNode&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;decision&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;makeNextDecision&lt;/span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;decision&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// Found a solution.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;solutionFound&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Assignments&lt;/span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;assignmentTried&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt; = &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;solutionFound&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// We can get here if we&amp;#39;re resuming from a previous solution. We&amp;#39;ll resume&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// by backtracking out of this node.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;assignmentTried&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;decision&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;valueAssigned&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;unassignmentTried&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt; = &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unassignmentTried&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt; {&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// We exhausted the search space, no solutions are left.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, &lt;code&gt;Run()&lt;/code&gt; is exceptionally straight-forward - it simply keeps calling &lt;code&gt;step()&lt;/code&gt; until &lt;code&gt;step()&lt;/code&gt; says it is &lt;code&gt;done&lt;/code&gt;, which happens either because a solution has been found, or the entire search space has been exhausted, and no more solutions as exist. On the other hand, &lt;code&gt;step()&lt;/code&gt; is a bit more complicated - it looks at the state that the current node is in and:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;For &lt;code&gt;freshNode&lt;/code&gt; search makes a decision; if that&amp;rsquo;s &lt;code&gt;nil&lt;/code&gt; then we have a solution, otherwise we create a child node and move into it.&lt;/li&gt;&lt;li&gt;For &lt;code&gt;solutionFound&lt;/code&gt; search simply backtracks, so that search can continue to the next solution.&lt;/li&gt;&lt;li&gt;For &lt;code&gt;assignmentTried&lt;/code&gt; search flips the assignment to &lt;em&gt;unassignment&lt;/em&gt; (e.g., if the assignment was \(A = 5\) it&amp;rsquo;ll become \(A \ne 5\)). This is where the binary nature of the search tree comes from, that I mentioned in my other posts.&lt;/li&gt;&lt;li&gt;For &lt;code&gt;unassignmentTried&lt;/code&gt; search knows that at this point no more solutions can be found in the current subtree and it needs to backtrack. If search detects that it is already at the root node, that means it has nowhere to backtrack to and there are no more solutions at all.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;And that&amp;rsquo;s the heart of the constructive search algorithm. A few important things are left out for now though, which make what is essentially just DFS effective. I&amp;rsquo;ll cover these later, but I will touch on them briefly here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Heuristics and decision making in general are alluded to with &lt;code&gt;s.makeNextDecision()&lt;/code&gt;, but not fleshed out. This part delegates the heavy lifting to the variable and value ordering heuristics, and while those can be as simple as lexicographic, can get relatively sophisticated.&lt;/li&gt;&lt;li&gt;Applying &lt;em&gt;constraint propagation&lt;/em&gt; after making decisions, and tracking its results, so that they may be retracted upon backtracking. This will allow search to quickly eliminate parts of search space that are guaranteed to not contain solutions.&lt;/li&gt;&lt;li&gt;Supporting &lt;em&gt;backjumping&lt;/em&gt; rather than just simple backtracking.&lt;/li&gt;&lt;/ul&gt;</description>
     </item>
   
     <item>
       <title>Solver basics</title>
       <link>https://blog.dawnofthe.dad/posts/solver-basics/</link>
       <pubDate>Sat, 02 Sep 2023 12:49:25 -0700</pubDate>
       
       <guid>https://blog.dawnofthe.dad/posts/solver-basics/</guid>
       <description>&lt;p&gt;In the &lt;a href=&#34;https://blog.dawnofthe.dad/posts/solver-intro/&#34;&gt;previous post&lt;/a&gt; I&amp;rsquo;ve given a quick overview of what the solver is about, and in this post I&amp;rsquo;ll dive a little bit deeper into the subject, using N-queens with just 4 queens as an example problem. More specifically, I&amp;rsquo;ll fully specify the problem by defining the variables and constraints, and then walk through what a simple search would do, ultimately finding a solution.&lt;/p&gt;&lt;h2 id=&#34;closer-look-at-n-queens-problem&#34;&gt;Closer look at N-queens problem&lt;/h2&gt;&lt;p&gt;To recap the previous post, the goal of solving the N-queens problem is to find a way to place N queens on an NxN chessboard in a way that the queens are not attacking each other. I also mentioned that a common way of modeling this problem is by having over variable per queen, where variable M represents the queen in column M, and this model choice effectively ensures that no pair of queens share the same column. One thing I omitted earlier is that each variable is also associated with its &lt;em&gt;domain&lt;/em&gt;, which is basically the set of values that could be assigned to the variable. For N-queens the domain of all variables is \(\set{1, &amp;hellip;, N}\). A value from this domain simply represents the row, from \(1\) to \(N\), that a particular queen is assigned to.&lt;/p&gt;&lt;p&gt;Constraints for N-queens get a little bit more interesting: by the definition of variables we know that no pair of queens will attack each other vertically, since they cannot share the same column, but we still need to make sure they will not attack each other horizontally and diagonally.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Preventing horizontal attacks&lt;/strong&gt; is the same thing as making sure that each queen is assigned to a different row, and this is a perfect example of applying the &lt;em&gt;all-different&lt;/em&gt; constraint. There are different ways of implementing such a constraint, but the net outcome is the same - all variables that are part of such a constraint must be assigned to different values. So we&amp;rsquo;ll define one &lt;em&gt;all-different&lt;/em&gt; constraint and apply it to all of the 4 queens, as this prevents them from horizontally attacking each other.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Preventing diagonal attacks&lt;/strong&gt; will require doing a bit of math to define the constraint: we know that when a pair of queens share a diagonal if we can draw a line between them with a slope of 1 or -1, and we want to prevent that. Using the &amp;ldquo;rise over run&amp;rdquo; formula we can express that as $$abs((y_2-y_1) / (x_2 - x_1)) \ne 1$$ Let&amp;rsquo;s get rid of division, because dealing with floats is not fun: $$abs(y_2 - y_1) \ne abs(x_2-x_1)$$ With that, we just need to add constraints for each pair of queens, so that gives us $${n \choose 2} = n(n-1)/2$$ binary constraints.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This completes the definition of an N-queens problem.&lt;/p&gt;&lt;h2 id=&#34;search-and-n-queens&#34;&gt;Search and N-queens&lt;/h2&gt;&lt;p&gt;Now that we&amp;rsquo;ve defined the N-queens problem, let&amp;rsquo;s see what searching for a solution looks like. We&amp;rsquo;ll look at the smallest non-trivial N-queens problem with a solution, which happens to be with 4 queens.&lt;/p&gt;&lt;p&gt;There are a couple more things to mention about search:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Making the right decisions during search is critical. For this, typically two types of heuristics are used: &lt;em&gt;variable ordering heuristics&lt;/em&gt;, which I mentioned in the previous post, and &lt;em&gt;value ordering heuristics&lt;/em&gt;. They tell search which variable to assign next, and to what value. Here we&amp;rsquo;ll assume that both are using lexicographic ordering, meaning we&amp;rsquo;ll assign queen in column 1 first (call it Q1), then in columns 2, 3 and finally 4. We&amp;rsquo;ll do the same for values; i.e., rows that we assign the queens to.&lt;/li&gt;&lt;li&gt;The other thing done during search is called &lt;em&gt;constraint propagation&lt;/em&gt;, which basically says &amp;ldquo;after search assigns a value, it will proactively adjust other unassigned variables by removing values that would break a constraint&amp;rdquo;. That might sound a bit complicated, so for now, we&amp;rsquo;ll assume that we don&amp;rsquo;t do this, and only evaluate constraints when picking the next value.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;We can now look at the example search for the 4-queens problem:&lt;/p&gt;&lt;p&gt;&lt;img src=&#34;https://blog.dawnofthe.dad/4q-tree.svg&#34; alt=&#34;Search tree for the 4 queens problem&#34;&gt;&lt;/p&gt;&lt;p&gt;In the diagram above, labels next to nodes represent the decision made to reach the node (aside from root node); e.g.; &amp;ldquo;Q2:3&amp;rdquo; means &amp;ldquo;assign queen in column #2 to row 3&amp;rdquo;. Because we are using lexicographic variable ordering you&amp;rsquo;ll also note that each level in the tree corresponds to assigning the next queen. In cases where we find it impossible to assign a value to the next queen without violating a constraint, we&amp;rsquo;ll label those with &amp;ldquo;X&amp;rdquo;; e.g., &amp;ldquo;Q4:X&amp;rdquo; means &amp;ldquo;we couldn&amp;rsquo;t place queen in column 4 as every possible spot is already under attack&amp;rdquo;. Those are always followed by a backtrack.&lt;/p&gt;&lt;h3 id=&#34;explaining-search-steps&#34;&gt;Explaining search steps&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Start with no decisions made at the root of the search tree.&lt;/li&gt;&lt;li&gt;Assign Q1 to 1; i.e., to place queen in column #1 on row #1. Then create a new child node and step into it.&lt;/li&gt;&lt;li&gt;Now we&amp;rsquo;ll assign Q2. Placement of Q1 means that Q2 cannot be on row #1 (horizontal constraint, aka all different constraint, is violated) or on row #2 (diagonal constraint is violated). So we&amp;rsquo;ll place it on row #3, create another child node, and step into it.&lt;/li&gt;&lt;li&gt;Now we&amp;rsquo;re &lt;em&gt;attempting&lt;/em&gt; to assign Q3. This is where things get more interesting: row #1 is under attack by Q1, and rows #2 through #4 are under attack by Q2. No decision can be made and we&amp;rsquo;ve hit a dead end. This is where &lt;em&gt;backtracking&lt;/em&gt; must take place, which basically means going back to the parent of the current node and stating that the decision it made earlier leads to no solutions. This is the leftmost leaf node with an X on it in the diagram.&lt;/li&gt;&lt;li&gt;We&amp;rsquo;re now back to finding a new value for Q2, as assigning it to row #3 didn&amp;rsquo;t work. Search will try row #4, and, as usual, create a child node for that and step into it.&lt;/li&gt;&lt;li&gt;We&amp;rsquo;re trying to assign Q3 again. Row #1 is still under attack by Q1, however, now that we&amp;rsquo;ve moved Q2 to row #4, Q3 can go on row #2. We&amp;rsquo;ll make this decision, create a new child node, and step into that.&lt;/li&gt;&lt;li&gt;We&amp;rsquo;re now down to our last queen - Q4! Alas, looking for a viable place to put it we&amp;rsquo;ll see that row #1 is taken by Q1, row #2 by Q3, row #3 is under attack diagonally by Q3, and row #4 is already taken by Q2. We cannot place Q4 without attacking one of the other queens, and we must backtrack.&lt;/li&gt;&lt;li&gt;Q3 must be moved from row #2, but it has nowhere else to go - we can&amp;rsquo;t place it on row #3 because Q1 attacks that diagonally, and #4 is already under attack by Q2. We must backtrack again.&lt;/li&gt;&lt;li&gt;Q2 must now be moved from row #4, but Q2 has exhausted possible places it could be placed, so we backtrack once again, and end up at the root node.&lt;/li&gt;&lt;li&gt;After all that work we learned that Q1 cannot be on row #1 and we&amp;rsquo;re back at the root node. We must try the next value, row #2, create a new child and step into it. Thankfully, the rest of the search is backtrack-free.&lt;/li&gt;&lt;li&gt;Q2 can only be on row #4 because Q1 attacks all others. So we place it, create a new child and step into that.&lt;/li&gt;&lt;li&gt;Q3 can only be on row #1 now. We do that, and create a new child + step into that again.&lt;/li&gt;&lt;li&gt;Q4 is last, and luckily it can be placed on row #3. All the variables are now assigned and none of the constraints are violated, and thus we have a solution!&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Side-note: my solver always makes binary decisions, so the logic would have been more like &amp;ldquo;try X, and if that fails, try &lt;em&gt;not&lt;/em&gt; X&amp;rdquo;. The net result would still be the same, but we would have a few more nodes in the search tree. I&amp;rsquo;ll cover the more exact mechanics of my solver separately.&lt;/p&gt;&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;&lt;p&gt;We&amp;rsquo;ve looked at how N-queens problem can be modeled as a constraint satisfaction problem, and how search traverses the search space by incrementally building up a search tree. We saw how the constraints prevent us from visiting parts of the tree that have no solutions, and how we recover from failure to find a solution in subtrees.&lt;/p&gt;</description>
     </item>
   
     <item>
       <title>Solver intro</title>
       <link>https://blog.dawnofthe.dad/posts/solver-intro/</link>
       <pubDate>Sat, 26 Aug 2023 22:43:00 +0000</pubDate>
       
       <guid>https://blog.dawnofthe.dad/posts/solver-intro/</guid>
       <description>&lt;p&gt;The underlying general purpose solver is the most interesting and most complex part of the backend; it&amp;rsquo;s also the thing I have now rewritten 3 times for various reasons. So I&amp;rsquo;m going to talk about that a bit: what it does, why it is interesting and challenging to build, and where it is at today.&lt;/p&gt;&lt;h2 id=&#34;the-problem&#34;&gt;The problem&lt;/h2&gt;&lt;p&gt;The solver is designed to solve &lt;a href=&#34;https://en.wikipedia.org/wiki/Constraint_satisfaction_problem&#34;&gt;constraint satisfaction problems&lt;/a&gt;; aka CSPs. These problems are generally expressed by some number of variables with constraints on these variables. Here are a couple of examples of CSPs:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;N-queens problem&lt;/strong&gt;: for an NxN chess board, how can one position the queens such that none of them are attacking each other? A common way of expressing this as a CSP is to have one variable per column (because having more than one queen per column clearly violates the requirement that queens should not attack each other) and constraints that ensure that no two queens share a row, or a diagonal.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Sudoku&lt;/strong&gt;: for a 9x9 grid, how can one fill in the grid with digits from 1 to 9 such that no row, column, or block has the digit appear more than once? A way to model this as a CSP is to have one variable per cell, so 81 variables total, and for each row, horizontal and block an &lt;em&gt;all-different&lt;/em&gt; constraint. Sudokus can also be generalized to NxN grids; e.g., 25x25 sudoku has cells which can be filled in with a value between 1 and 25 and 25 rows, columns, and blocks.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;the-solver&#34;&gt;The solver&lt;/h2&gt;&lt;p&gt;There are a few different kinds of solvers for CSPs, the kind I have built is a constructive solver which has the ability to enumerate all solutions to a CSP, and similarly, guarantee that no solutions exist when that is the case. Here&amp;rsquo;s a quick rundown in bullet-form of how it works:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The core algorithm is building a tree that searches for a solution by making decisions, and after making a decision seeing if a solution still exists.&lt;/li&gt;&lt;li&gt;A decision is basically of the form &amp;ldquo;I think I can put the first queen on row #2&amp;rdquo;. Once a decision is made it holds until the solver either finds a solution that includes that decision, or proves that no solution exists with that decision.&lt;/li&gt;&lt;li&gt;When the solver does learn that no solutions exist based on an earlier decision, it backtracks; i.e., undoes that decision.&lt;/li&gt;&lt;li&gt;This algorithm will thus try all possibilities until an answer is found, or no answer is proven to exist.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;TL;DR: the algo is basically just DFS (depth first search). Easy peasy, right?&lt;/p&gt;&lt;p&gt;&amp;hellip; wait, the number of possible states gets pretty obscene, doesn&amp;rsquo;t it? Sure does! So how do we have any hope of finding a solution? Well, we&amp;rsquo;ll need to be smart about how we explore the possible states (aka the search space):&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;When making a decision we can be more careful about what that decision is. For example, we may want to pick a queen that only has two possible spots where it won&amp;rsquo;t be attacked. This is an example of &lt;em&gt;first fail&lt;/em&gt; variable ordering heuristic.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;After making a decision, like &amp;ldquo;first queen goes on row #2&amp;rdquo;, we can deduce that placing other queens on the same row doesn&amp;rsquo;t make any sense, and not attempt doing so. This is an example of &lt;em&gt;constraint propagation&lt;/em&gt;. Conveniently, this makes it easier for us to choose the next queen (see previous bullet point).&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;We can get smart about recovering from failing to find a solution. An example of this is &lt;em&gt;backjumping&lt;/em&gt;, where rather than going back to the latest decision, i.e., simply &lt;em&gt;backtracking&lt;/em&gt;, we jump further back and skip parts of the search tree that are guaranteed to not have a solution.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I&amp;rsquo;ll cover these in separate posts, but for now hopefully this gives you an idea how the simplistic-looking DFS algorithm can be extended and handle traversing rather obscene search spaces.&lt;/p&gt;&lt;h3 id=&#34;why-its-hard-to-build&#34;&gt;Why it&amp;rsquo;s hard to build&lt;/h3&gt;&lt;p&gt;In short, because the search space is huge, optimization becomes critical. This applies to just about every step of the search process, from efficiently representing the problem and the search state, to efficiently updating the state and auxillary data structures, to quickly and correctly applying the techniques above, like constraint propagation and backjumping. I&amp;rsquo;ll cover these in more detail later as I intend to write some posts about different kinds of &lt;em&gt;all-different&lt;/em&gt; constraints, constraint propagation in general, and backjumping vs backtracking.&lt;/p&gt;&lt;h3 id=&#34;where-it-is-today&#34;&gt;Where it is today&lt;/h3&gt;&lt;p&gt;The solver runs on an E2 instance in Google Cloud, on freebie quota. As such, there are significant limitations to the CPU and RAM, yet it is still able to easily chew through most 15x15 crosswords and generalized NxN sudokus, up to 36x36 in size. The solver itself also supports finding &lt;em&gt;the best solution&lt;/em&gt; and not just any solution, which requires providing an &lt;em&gt;objective function&lt;/em&gt; as part of the problem, however this isn&amp;rsquo;t yet surfaced through the site. An example application would be picking words for a crossword that are more common and avoiding other words, like abbreviations. There are also other, &amp;ldquo;infrastructural&amp;rdquo; improvements, which I may get to in the future. I may also look to apply the solver to a new class of problems, but I&amp;rsquo;m not sure what those will be yet.&lt;/p&gt;&lt;p&gt;With that, I&amp;rsquo;ll close this post out with a quick plug for my solver for &lt;a href=&#34;https://dawnofthe.dad/ndoku&#34;&gt;NxN sudoku&lt;/a&gt; where you can see that by applying the techniques mentioned here the solver is able to find a solution for a 25x25 sudoku in a couple of seconds. In contrast, with a pure brute-force algorithm, we may need to consider an enormous number of states: $$(25 \times 25) ^ {25} = 7.889 \times 10^{69}$$&lt;/p&gt;</description>
     </item>
   
     <item>
       <title>Why tho</title>
       <link>https://blog.dawnofthe.dad/posts/why-tho/</link>
       <pubDate>Sat, 26 Aug 2023 21:00:03 +0000</pubDate>
       
       <guid>https://blog.dawnofthe.dad/posts/why-tho/</guid>
       <description>&lt;h2 id=&#34;what-and-why&#34;&gt;What and why?&lt;/h2&gt;&lt;p&gt;First, the &lt;strong&gt;what&lt;/strong&gt;: &lt;a href=&#34;https://dawnofthe.dad&#34;&gt;Dawn of the Dad&lt;/a&gt; is basically the 2 solvers: one for &lt;a href=&#34;https://dawnofthe.dad/sudoku&#34;&gt;sudoku&lt;/a&gt;, and another for &lt;a href=&#34;https://dawnofthe.dad/crossword&#34;&gt;building crosswords&lt;/a&gt;. The first is largely complete, so most of my time now is dedicated to beefing up the crossword builder.&lt;/p&gt;&lt;p&gt;Now the &lt;strong&gt;why&lt;/strong&gt;: why build the site and why ramble in this blog?&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;The site is my excuse to write some code, both to stay sharp and because I like doing it, solve some algorithmically interesting problems, and revisit some of the neat things I&amp;rsquo;ve learned about back in grad school. Originally, this spun off as a yet-another-rewrite of a general-purpose &lt;a href=&#34;https://en.wikipedia.org/wiki/Constraint_satisfaction_problem&#34;&gt;CSP&lt;/a&gt; solver, which then led to adding fairly ad hoc visualization, which led to building a web server, hacking up a websocket protocol, glueing it all together and finally hosting it on Google Cloud.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The blog is largely meant to capture some of the interesting things I&amp;rsquo;ve learned along the way, like tuning / optimizing the solver and dealing with the hug of death I got from that one time my site briefly hit the front page of &lt;a href=&#34;https://news.ycombinator.com/news&#34;&gt;Hacker News&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;post-frequency&#34;&gt;Post frequency&lt;/h2&gt;&lt;p&gt;I&amp;rsquo;ll probably end up writing a bunch of posts relatively quickly at first, as I&amp;rsquo;m catching up on a year&amp;rsquo;s worth of potentially interesting things to write down, before I forget them. Once I do, I expect things to slow down a fair bit.&lt;/p&gt;</description>
     </item>
   
 </channel>
</rss>
