<!doctype html><html lang=en-us><head><title>All Different Variants - Blog of the Dad</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=" Blog of the Dad"><meta name=author content="Andrei"><meta property="og:title" content="All Different Variants"><meta property="og:description" content="In the earlier posts I&rsquo;ve described some of the basic ideas behind CSPs:
how the problems are represented using variables and constraints, how the solver searches for a solution by building up the search tree, how heuristics guide the search, and how constraint propagation helps eliminate parts of the search space that will not contain solutions. In this post I will look at how modeling the problem itself can have a significant influence on how quickly the solver is able to find a solution."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.dawnofthe.dad/posts/all-different-variants/"><meta property="og:image" content="https://blog.dawnofthe.dad/spongebob-crossed-eyes.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-12T18:21:01-08:00"><meta property="article:modified_time" content="2023-11-12T18:21:01-08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.dawnofthe.dad/spongebob-crossed-eyes.jpg"><meta name=twitter:title content="All Different Variants"><meta name=twitter:description content="In the earlier posts I&rsquo;ve described some of the basic ideas behind CSPs:
how the problems are represented using variables and constraints, how the solver searches for a solution by building up the search tree, how heuristics guide the search, and how constraint propagation helps eliminate parts of the search space that will not contain solutions. In this post I will look at how modeling the problem itself can have a significant influence on how quickly the solver is able to find a solution."><meta name=generator content="Hugo 0.117.0"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=/android-chrome-192x192.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=apple-mobile-web-app-title content="Blog of the Dad"><meta name=application-name content="Blog of the Dad"><meta name=msapplication-TileColor content="#da532c"><meta name=msapplication-TileImage content="/mstile-144x144.png"><meta name=theme-color content="#ffffff"><script src=/js/mathjax-config.js defer></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous><link rel=stylesheet href=https://blog.dawnofthe.dad/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=/css/styles.css></head><body><div id=container><header><h1><a href=/>Blog of the Dad</a></h1><ul id=social-media><li><a href=https://twitter.com/userundefinedrd title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://reddit.com/u/userundefined title=Reddit><i class="fab fa-reddit-alien fa-lg"></i></a></li></ul><p><em>Donâ€™t eat me. I have a wife and kids. Eat them.</em></p></header><nav><ul></ul></nav><main><article><h1>All Different Variants</h1><aside><ul><li><time class=post-date datetime=2023-11-12T18:21:01-08:00>Nov 12, 2023</time></li><li><em><a href=/tags/algorithms>#Algorithms</a>
,
<a href=/tags/go>#Go</a></em></li><li>13 minute read</li></ul></aside><div class=featured_image><a href=https://blog.dawnofthe.dad/posts/all-different-variants/ title="All Different Variants"><img src=/spongebob-crossed-eyes.jpg></a></div><p>In the earlier posts I&rsquo;ve described some of the basic ideas behind CSPs:</p><ul><li>how the problems are represented using variables and constraints,</li><li>how the solver searches for a solution by building up the search tree,</li><li>how heuristics guide the search, and</li><li>how constraint propagation helps eliminate parts of the search space that will not contain solutions.</li></ul><p>In this post I will look at how modeling the problem itself can have a significant influence on how quickly the solver is able to find a solution. In particular, I&rsquo;ll talk about different ways of implementing the <em>all-different</em> constraint, and look at the various implementations&rsquo; performance characteristics.</p><h2 id=choices-choices>Choices, choices&mldr;</h2><p>An interesting thing about CSPs is that for a given problem type there is often more than one way to model it. For example, when I spoke about <a href=https://blog.dawnofthe.dad/posts/solver-basics/>modeling the N-queens problem</a> I said that one way to prevent queens from attacking each other diagonally is to ensure that if any pair of queens are connected by a line the slope of that line isn&rsquo;t 1 or -1. Another way to achieve the same result is to enumerate diagonals of the NxN chessboard, and make sure that all queens are assigned to different diagonals (each queen will claim two diagonals - one from bottom left to top right and another from top left to bottom right). Both representations are totally valid, but the performance of search will vary depending on how the problem is modeled, and how the underlying constraints are implemented.</p><p>In fact, the &ldquo;all diagonals must be different&rdquo; constraint can be implemented by having binary constraints, one for each pair of queens, that ensure that the queens don&rsquo;t each other diagonally, which is exactly how I&rsquo;ve described the problem originally. Importantly though, the all-different constraint could be implemented very differently.</p><h2 id=all-different-constraint>All different constraint</h2><p>Before getting too far ahead, let&rsquo;s formally define what an <em>all-different</em> constraint means. Recall that a CSP itself is composed of variables, each with a domain of possible values, and constraints on those variables. An <em>all-different</em> constraint may defined on any subset of variables of the overall problem, and it is satisfied if the following condition is true:
$$ \forall u, v \in C_V: value(u) \ne value(v) $$</p><p>From this representation, it&rsquo;s easy to see why it can be tempting, and totally valid, to model this constraint just as a set of binary <em>not-equals</em> constraints.</p><h3 id=constraint-interface>Constraint interface</h3><p>In my solver all constraints implement the following interface:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Constraint</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Variables</span>() []<span style=color:#f92672>*</span><span style=color:#a6e22e>Variable</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Supported</span>(<span style=color:#a6e22e>v</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Variable</span>, <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When the solver applies constraint propagation it checks constraints by iterating over its <code>Variables()</code> and checking whether the remaining values in each of the variable&rsquo;s live domains are still <code>Supported()</code> by the constraint. When they are not, they are removed as no solution can exist with that variable-value assignment. You can see how constraint propagation works in the <a href=https://blog.dawnofthe.dad/posts/constraint-propagation/>earlier post</a>.</p><h2 id=all-different-constraint-implementations>All-different constraint implementations</h2><p>There are many ways to enforce this constraint. Let&rsquo;s look at a bunch.</p><h3 id=binary>Binary</h3><p>We&rsquo;ve already covered the simplest, which boils down to taking each pair of variables and adding binary <em>not-equal</em> constraints. This is exactly what we did with N-queens, and results in a quadratic number of binary constraints. One big benefit of this approach is just how easy it is to understand and implement.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>buildBinaryAllDiff</span>(<span style=color:#a6e22e>vs</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>Variable</span>) []<span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>Constraint</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>cs</span> <span style=color:#f92672>:=</span> []<span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>Constraint</span>{}
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>vs</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>j</span> &lt; len(<span style=color:#a6e22e>vs</span>); <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>cs</span> = append(<span style=color:#a6e22e>cs</span>, <span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>NewNotEquals</span>(<span style=color:#a6e22e>vs</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>vs</span>[<span style=color:#a6e22e>j</span>]))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>cs</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=basic>Basic</h3><p>Rather than defining many binary constraints, we can do a bit better by defining a single constraint that tracks variables with one live value left and disallows assigning that value to any of the other variables.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>allDiffBasic</span> <span style=color:#66d9ef>struct</span> { <span style=color:#a6e22e>vs</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>Variable</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>allDiffBasic</span>) <span style=color:#a6e22e>Variables</span>() []<span style=color:#f92672>*</span><span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>Variable</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>vs</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>allDiffBasic</span>) <span style=color:#a6e22e>Supported</span>(<span style=color:#a6e22e>supV</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>Variable</span>, <span style=color:#a6e22e>supVal</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>other</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>vs</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>supV</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>other</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>other</span>.<span style=color:#a6e22e>LiveLeft</span>() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>other</span>.<span style=color:#a6e22e>LiveDomain</span>().<span style=color:#a6e22e>LastLiveValue</span>() <span style=color:#f92672>==</span> <span style=color:#a6e22e>supVal</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=sparse>Sparse</h3><p>This one is a little bit more clever by being incremental and tracking state change - whenever a variable is assigned, we track which value is &ldquo;claimed&rdquo; and disallow other variables from that value, and when a variable is unassigned, we allow other variables to be assigned to that value again. You can see that happening in the <code>Set()</code> and <code>Cleared()</code> methods below, which are part of incremental interface (not shown).</p><p>This is very similar in spirit to &ldquo;Basic&rdquo;, but doesn&rsquo;t require explicitly checking every variable whenever we&rsquo;re seeing if the constraint is violated. The reason I call this type of implementation <em>sparse</em> is because it works well when we have many values to choose from. This is the implementation I use for the <a href=https://dawnofthe.dad/crossword>crossword builder</a>, for ensuring words are not repeated - there are very many words in the dictionary to choose from&mldr; but more on this another time.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>allDiffSparse</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>vs</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>Variable</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>claimedValues</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>allDiffSparse</span>) <span style=color:#a6e22e>Variables</span>() []<span style=color:#f92672>*</span><span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>Variable</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>vs</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>allDiffSparse</span>) <span style=color:#a6e22e>Supported</span>(<span style=color:#a6e22e>supV</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>Variable</span>, <span style=color:#a6e22e>supVal</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> !<span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>claimedValues</span>[<span style=color:#a6e22e>supVal</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>allDiffSparse</span>) <span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>v</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>Variable</span>, <span style=color:#a6e22e>value</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>claimedValues</span>[<span style=color:#a6e22e>value</span>] = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>allDiffSparse</span>) <span style=color:#a6e22e>Cleared</span>(<span style=color:#a6e22e>v</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>Variable</span>, <span style=color:#a6e22e>prevValue</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>  delete(<span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>claimedValues</span>, <span style=color:#a6e22e>prevValue</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=pigeonhole>Pigeonhole</h3><p>This implementation is based on the <a href=https://en.wikipedia.org/wiki/Pigeonhole_principle>Pigeonhole principle</a>, which, to quote Wikipedia, <em>states that if n items are put into m containers, with n > m, then at least one container must contain more than one item</em>. In other words, if we ever get to a state where we have fewer values left to choose from than unassigned variables, we know that the <em>all-different</em> constraint cannot be met. For example, this implementation can detect that if we have three variables, each with domain of {1, 2}, no solution is possible. The more naive implementations would not. So while they all will enforce the constraint given a full assignment, this one can detect infeasibility earlier, saving us from pointlessly trying to find a solution when none exist.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>allDiffPigeonHole</span> <span style=color:#66d9ef>struct</span> { <span style=color:#a6e22e>vs</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>Variable</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>allDiffPigeonHole</span>) <span style=color:#a6e22e>Variables</span>() []<span style=color:#f92672>*</span><span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>Variable</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>vs</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>allDiffPigeonHole</span>) <span style=color:#a6e22e>Supported</span>(<span style=color:#a6e22e>supV</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>Variable</span>, <span style=color:#a6e22e>supVal</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>otherVals</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>bool</span>{}
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>other</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>vs</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>supV</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>other</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>atLeastOneSupport</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>other</span>.<span style=color:#a6e22e>LiveDomain</span>().<span style=color:#a6e22e>ForEachValue</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>value</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>value</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>supVal</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>otherVals</span>[<span style=color:#a6e22e>value</span>] = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>atLeastOneSupport</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>atLeastOneSupport</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> len(<span style=color:#a6e22e>otherVals</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;=</span> len(<span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>vs</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=bi-partite>Bi-partite</h3><p>This implementation is the most thorough, because it performs a bi-partite match from variables on one side to possible values on the other, and only succeeds when a maximum match exists. In other words, given a partial assignment of values to variables, this constraint will only remain feasible when a possible all-different assignment still exists. An overly simple example to demonstrate that this implementation is more powerful than pigeonhole one is this:</p><ul><li>A problem with 3 variables: X, Y and Z.</li><li>X must be 1, Y must 1, but Z can be either 2 or 3.</li><li>Pigeonhole implementation will say there are 3 values and 3 variables, so a solution might exist, but clearly there is no maximal bipartite match as X and Y will be equal, so the more sophisticated bipartite implementation will flag this as an infeasible state.</li><li>As a side-note, while pigeonhole wouldn&rsquo;t detect infeasibilty in this example, all of the simpler constraints would. So it&rsquo;s not true that pigeonhole is strictly stronger than the simpler implementations, but it is true that the bipartite one is.</li></ul><p>There&rsquo;s ~250 lines of code for this one, so I won&rsquo;t include that verbatim, but in short this implementation uses Hopcroft-Karp maximum matching algorithm, porting <a href=https://www.geeksforgeeks.org/hopcroft-karp-algorithm-for-maximum-matching-set-2-implementation/>this implementation</a> to Go, and adds incremental state tracking; e.g., by removing edges from the match as variables are assigned. When the constraint is re-evaluated via <code>Supported()</code>, this allows to start from a partial and often mostly complete matching, rather than from scratch.</p><h2 id=comparing-performance>Comparing performance</h2><p>Cool, so we&rsquo;ve got the implementations. We know that ultimately they&rsquo;ll all give us to a valid sudoku, but what is their performance like? Let&rsquo;s look!</p><h3 id=the-setup>The setup</h3><p>We&rsquo;ll be looking at generalized NxN sudokus, as they are effectively one big glob of variables, one per sudoku cell, and <em>all-different</em> constraints enforcing horizontal, vertical and block uniqueness. We&rsquo;ll search for the first, randomly encountered solution, and to do so we&rsquo;ll be using a solver with randomized variable and value ordering <a href=https://blog.dawnofthe.dad/posts/heuristics/>heuristics</a> and apply <a href=https://blog.dawnofthe.dad/posts/constraint-propagation/>forward checking</a> after every assignment. We&rsquo;ll be looking at sudokus of sizes 16x16, 25x25 and 36x36. You can also try most of these <a href=https://dawnofthe.dad/ndoku>online</a>.</p><p>We&rsquo;ll cover two basic metrics - time taken by the solver, and the number of steps the solver took, to reach the first solution. End users will typically only care about the time taken, but the number of steps can give us some insights into how our constraints work.</p><p>We&rsquo;ll be using Go&rsquo;s benchmarking tests to evaluate performance of these implementations. Here&rsquo;s what this benchmark/test looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>timeout</span> = <span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Minute</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>experiment</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// For my sudokus &#34;size&#34; is the size of a subsquare, so 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// &#34;size = 3&#34; results in a regular 9x9 sudoku, and so on.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>size</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>kind</span> <span style=color:#a6e22e>alldiff</span>.<span style=color:#a6e22e>AlgoKind</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>experiments</span> = []<span style=color:#a6e22e>experiment</span>{
</span></span><span style=display:flex><span>  {<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;basic&#34;</span>, <span style=color:#a6e22e>size</span>: <span style=color:#ae81ff>4</span>, <span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>alldiff</span>.<span style=color:#a6e22e>Basic</span>},
</span></span><span style=display:flex><span>  {<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;binary&#34;</span>, <span style=color:#a6e22e>size</span>: <span style=color:#ae81ff>4</span>, <span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>alldiff</span>.<span style=color:#a6e22e>Binary</span>},
</span></span><span style=display:flex><span>  {<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;sparse&#34;</span>, <span style=color:#a6e22e>size</span>: <span style=color:#ae81ff>4</span>, <span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>alldiff</span>.<span style=color:#a6e22e>Sparse</span>},
</span></span><span style=display:flex><span>  {<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;pigeonhole&#34;</span>, <span style=color:#a6e22e>size</span>: <span style=color:#ae81ff>4</span>, <span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>alldiff</span>.<span style=color:#a6e22e>Pigeonhole</span>},
</span></span><span style=display:flex><span>  {<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;bipartite&#34;</span>, <span style=color:#a6e22e>size</span>: <span style=color:#ae81ff>4</span>, <span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>alldiff</span>.<span style=color:#a6e22e>Bipartite</span>},
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  {<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;basic-lg&#34;</span>, <span style=color:#a6e22e>size</span>: <span style=color:#ae81ff>5</span>, <span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>alldiff</span>.<span style=color:#a6e22e>Basic</span>},
</span></span><span style=display:flex><span>  {<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;binary-lg&#34;</span>, <span style=color:#a6e22e>size</span>: <span style=color:#ae81ff>5</span>, <span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>alldiff</span>.<span style=color:#a6e22e>Binary</span>},
</span></span><span style=display:flex><span>  {<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;sparse-lg&#34;</span>, <span style=color:#a6e22e>size</span>: <span style=color:#ae81ff>5</span>, <span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>alldiff</span>.<span style=color:#a6e22e>Sparse</span>},
</span></span><span style=display:flex><span>  {<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;pigeonhole-lg&#34;</span>, <span style=color:#a6e22e>size</span>: <span style=color:#ae81ff>5</span>, <span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>alldiff</span>.<span style=color:#a6e22e>Pigeonhole</span>},
</span></span><span style=display:flex><span>  {<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;bipartite-lg&#34;</span>, <span style=color:#a6e22e>size</span>: <span style=color:#ae81ff>5</span>, <span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>alldiff</span>.<span style=color:#a6e22e>Bipartite</span>},
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  {<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;basic-vlg&#34;</span>, <span style=color:#a6e22e>size</span>: <span style=color:#ae81ff>6</span>, <span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>alldiff</span>.<span style=color:#a6e22e>Basic</span>},
</span></span><span style=display:flex><span>  {<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;binary-vlg&#34;</span>, <span style=color:#a6e22e>size</span>: <span style=color:#ae81ff>6</span>, <span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>alldiff</span>.<span style=color:#a6e22e>Binary</span>},
</span></span><span style=display:flex><span>  {<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;sparse-vlg&#34;</span>, <span style=color:#a6e22e>size</span>: <span style=color:#ae81ff>6</span>, <span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>alldiff</span>.<span style=color:#a6e22e>Sparse</span>},
</span></span><span style=display:flex><span>  {<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;pigeonhole-vlg&#34;</span>, <span style=color:#a6e22e>size</span>: <span style=color:#ae81ff>6</span>, <span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>alldiff</span>.<span style=color:#a6e22e>Pigeonhole</span>},
</span></span><span style=display:flex><span>  {<span style=color:#a6e22e>name</span>: <span style=color:#e6db74>&#34;bipartite-vlg&#34;</span>, <span style=color:#a6e22e>size</span>: <span style=color:#ae81ff>6</span>, <span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>alldiff</span>.<span style=color:#a6e22e>Bipartite</span>},
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>solveSudoku</span>(<span style=color:#a6e22e>e</span> <span style=color:#a6e22e>experiment</span>) (<span style=color:#66d9ef>bool</span>, <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sudoku</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>GeneralizedSudoku</span>(<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>size</span>, <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>{}, <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>kind</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>config</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>search</span>.<span style=color:#a6e22e>Config</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>VariableHeuristic</span>: <span style=color:#a6e22e>search</span>.<span style=color:#a6e22e>NewDomWDegVariableHeuristic</span>(<span style=color:#a6e22e>sudoku</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ValueHeuristic</span>:    <span style=color:#a6e22e>search</span>.<span style=color:#a6e22e>NewRandomValueHeuristic</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>().<span style=color:#a6e22e>UTC</span>().<span style=color:#a6e22e>UnixNano</span>()),
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>search</span>.<span style=color:#a6e22e>NewSearch</span>(<span style=color:#a6e22e>sudoku</span>, <span style=color:#a6e22e>config</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>cancel</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithTimeout</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(), <span style=color:#a6e22e>timeout</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>cancel</span>()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>solved</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>ctx</span>) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>solved</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Steps</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkSudoku</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>experiments</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>OpenFile</span>(<span style=color:#e6db74>&#34;benchmarks/&#34;</span><span style=color:#f92672>+</span><span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>name</span><span style=color:#f92672>+</span><span style=color:#e6db74>&#34;.dat&#34;</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>O_RDWR</span>|<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>O_CREATE</span>|<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>O_TRUNC</span>, <span style=color:#ae81ff>0755</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewWriter</span>(<span style=color:#a6e22e>f</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>name</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>solved</span>, <span style=color:#a6e22e>steps</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>solveSudoku</span>(<span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>timeTaken</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>start</span>).<span style=color:#a6e22e>Microseconds</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteString</span>(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%v %v %s\n&#34;</span>, <span style=color:#a6e22e>timeTaken</span>, <span style=color:#a6e22e>steps</span>, <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>FormatBool</span>(<span style=color:#a6e22e>solved</span>)))
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Flush</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The performance data is then generated via:</p><p><code>go test -bench=BenchmarkSudoku -benchtime=500x -run=^# -timeout=24h</code></p><p>and plotted with gnuplot. I generated 1000 instances for 16x16, 500 for 25x25, and 200 for 36x36 graphs.</p><h3 id=steps-taken>Steps taken</h3><p>We&rsquo;ll look at steps taken first, because there is a clear winner - as one might expect, the most sophisticated bipartite implementation wins hands-down. In fact, if you try it online with lexicographic ordering you&rsquo;ll notice that it rarely needs to backtrack. Even with randomized ordering it backtracks far less than the alternatives.</p><p>Here is the performance of the five implementations for 16x16 sudokus (all graphs in this post are <a href=https://en.wikipedia.org/wiki/Cumulative_distribution_function>cumulative distribution functions</a>):</p><p><img src=/plots/cdf-steps.png alt="16x16 Sudoku - steps taken"></p><p>Bipartite is the fastest, and it is followed closely by pigeonhole. Basic is in third, followed by binary, and with sparse coming in last. These last three don&rsquo;t perform particularly great in terms of steps taken. One interesting bit is that basic takes slightly fewer steps than sparse - I think this is because it is slightly more aggresive at removing values, as it considers all variables with one variable, rather that just assigned variables like sparse does (so it can cover cases where a variable is not assigned yet, but its live domain only has one value left).</p><h3 id=runtime>Runtime</h3><p><img src=/plots/cdf-time.png alt="16x16 Sudoku - time taken"></p><p>Pretty different from steps taken, eh? Let&rsquo;s see what&rsquo;s going on here:</p><ul><li>Sparse, the slowest in terms of number of steps, is performing really well when it comes to time. Why? There are a couple of reasons: the speed of evaluating a given constraint, and the fact that we only have one constraint for each set of 16 cells. It&rsquo;s fast because it incrementally maintains state, and when asked if a value is still viable just checks if it has already been taken. And, unlike binary constraints, where we&rsquo;d have 120 binary constraints to represent all-difference of 16 cells (15 * 16 / 2 = 120), there&rsquo;s only one constraint to check. 16x16 sudokus also appear to be under-constrained, so this fast, simple implementation, does well.</li><li>Basic comes in next. This isn&rsquo;t too surprising given it is similar to sparse, but not incremental, and hence a bit slower, despite taking fewer steps.</li><li>Bipartite follows. It&rsquo;s sophisticated, but slower than the simpler implementations above. It <em>is</em> incremental though, which is important in that when the state changes, the re-evaluations are generally quick.</li><li>Binary is second to last for most percentiles (and in fact it is the worst at high percentiles). Here, we have the benefits of &ldquo;simple and fast&rdquo; evaluation, but we have more constraints to evaluate, and this ultimately hurts the runtime, despite the simplicity.</li><li>Pigeonhole is the slowest of the bunch, and this is primarily/probably because it is not incremental, so every time it is evaluated, it is somewhat expensive to do so. We won&rsquo;t look at it again, as it scales poorly for larger puzzles.</li></ul><h3 id=larger-instances>Larger instances</h3><p>Well, our sophisticated implementation didn&rsquo;t exactly kick butt in terms of time on the smaller instances. Let&rsquo;s look at 25x25 sudokus next. Here, the less sophisticated variants start getting rather slow, so to keep things simple I&rsquo;m capping their runtime at 10 minutes. The timeouts aren&rsquo;t too frequent yet:</p><ul><li>Basic: 6/500 runs timed out.</li><li>Binary: 19/500 runs timed out.</li><li>Sparse: 6/500 runs timed out.</li></ul><p><img src=/plots/cdf-large-steps.png alt="25x25 Sudoku - steps taken"></p><p>Looking at steps taken, as before, we can see that bipartite implementation is far smarter and takes way fewer steps than others. Pigeonhole is second best, as before. This isn&rsquo;t too surprising, but perhaps what is interesting is how quickly the simpler implementations start to degrade.</p><p><img src=/plots/cdf-large-time.png alt="25x25 Sudoku - time taken"></p><p>Looking at the runtime reinforces that story - the less sophisticated implementations complete about an order of magnitude faster when they&rsquo;re &ldquo;lucky&rdquo;, but <strong>many</strong> orders of magnitude slower when they are not (say, at 95 percentile). So, while on average a couple of these implementations are competitive, on occasion we can hit particularly bad runs that take many minutes to complete&mldr; and binary, the simplest of them all, clearly is struggling to keep up. In contrast, the bipartite implementation is very steady, with basically all of the runs completing in 1.5 - 2 seconds. Pigeonhole isn&rsquo;t quite as fast as bipartite, but still tends to hold up well against the simpler implementations. The runtime of the top few percentiles does get significantly worse though.</p><h3 id=even-larger-instances>Even larger instances</h3><p>The even larger, 36x36 set of sudokus, is where we can see the that the simpler approaches start consistently timing out after 10 minutes:</p><ul><li>Basic: 25/30 runs timed out.</li><li>Binary: 28/30 runs timed out.</li><li>Sparse: 24/30 runs timed out.</li></ul><p>These make sense - based on the smaller instances we already noticed that all 3 of these tend to require many more steps, binary suffers from having too many finer-grained constraints to evaluate, basic is non-incremental, and sparse is only a slight improvement over basic. So none of them do well, binary is worse than the other two, while the incrementality of sparse over basic may be slightly helping (albeit the sample size is too small to be certain).</p><p>Only bipartite and pigeonhole implementations remain viable, with bipartite continuing to be in the lead:</p><p><img src=/plots/cdf-very-large-steps.png alt="36x36 Sudoku - steps taken"></p><p><img src=/plots/cdf-very-large-time.png alt="36x36 Sudoku - time taken"></p><p>In short, bipartite is clearly starting to win, and the trend continues for larger instances, based on a handful of ad hoc experiments.</p><h2 id=takeaways>Takeaways</h2><p>Like with many things, it comes down to trade-offs. In this case, choosing the right implementation of an <em>all-different</em> constraint comes down to choosing between simplicity, speed, and consistent performance. Determining which of these is more important to you can help you choose the right implementation:</p><ul><li>Fast implementations are easy to understand, and can be &ldquo;good enough&rdquo; for smaller problems, but have unstable run times, and don&rsquo;t scale well.</li><li>More sophisticated implementations are the opposite, they&rsquo;re harder to understand and implement, don&rsquo;t provide a ton of value on smaller problems, but truly shine on large problems, and have consistent performance characteristics to boot.</li></ul><p>Lastly, it&rsquo;s worth noting that more efficient algorithms for <em>all-different</em> constraints and sudokus are out there, and I&rsquo;ve yet to experiment with them. <a href=https://www.ijcai.org/Proceedings/03/Papers/036.pdf>Regin&rsquo;s all-different algorithm</a> and <a href=https://en.wikipedia.org/wiki/Dancing_Links>Knuth&rsquo;s Dancing links algorithm</a> are two examples of these, respectively.</p></article><section class=post-nav><ul><li><a href=https://blog.dawnofthe.dad/posts/rubber-duck-ftw/><i class="fa fa-chevron-circle-left"></i> Rubber Duck FTW</a></li><li></li></ul></section></main><footer><ul><li><h6>Rendered by
<a href=https://gohugo.io title=Hugo>Hugo</a> and based on a fork of the <a href=https://themes.gohugo.io/themes/hugo-kiera/>Kiera theme</a> |
<link href=/feed.xml type=application/atom+xml rel=alternate title="Blog of the Dad"><a href=https://blog.dawnofthe.dad/index.xml>Subscribe</a></h6></li></ul></footer></div><script src=/js/scripts.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WS2FCBYJLF"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WS2FCBYJLF",{anonymize_ip:!1})}</script></body></html>