
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
   <title>Posts on Blog of the Dad</title>
   <link>https://blog.dawnofthe.dad/posts/</link>
   <description>Recent content in Posts on Blog of the Dad</description>
   <generator>Hugo -- gohugo.io</generator>
   <language>en-us</language>
   <lastBuildDate>Sat, 26 Aug 2023 22:43:00 +0000</lastBuildDate>
   
       <atom:link href="https://blog.dawnofthe.dad/posts/index.xml" rel="self" type="application/rss+xml" />
   
   
     <item>
       <title>Solver intro</title>
       <link>https://blog.dawnofthe.dad/posts/solver-intro/</link>
       <pubDate>Sat, 26 Aug 2023 22:43:00 +0000</pubDate>
       
       <guid>https://blog.dawnofthe.dad/posts/solver-intro/</guid>
       <description>&lt;p&gt;The underlying general purpose solver is the most interesting and most complex part of the backend; it&amp;rsquo;s also the thing I have now rewritten 3 times for various reasons. So I&amp;rsquo;m going to talk about that a bit: what it does, why it is interesting and challenging to build, and where it is at today.&lt;/p&gt;&lt;h2 id=&#34;the-problem&#34;&gt;The problem&lt;/h2&gt;&lt;p&gt;The solver is designed to solve &lt;a href=&#34;https://en.wikipedia.org/wiki/Constraint_satisfaction_problem&#34;&gt;constraint satisfaction problems&lt;/a&gt;; aka CSPs. These problems are generally expressed by some number of variables with constraints on these variables. Here are a couple of examples of CSPs:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;N-queens problem&lt;/strong&gt;: for an NxN chess board, how can one position the queens such that none of them are attacking each other? A common way of expressing this as a CSP is to have one variable per column (because having more than one queen per column clearly violates the requirement that queens should not attack each other) and constraints that ensure that no two queens share a row, or a diagonal.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;Sudoku&lt;/strong&gt;: for a 9x9 grid, how can one fill in the grid with digits from 1 to 9 such that no row, column, or block has the digit appear more than once? A way to model this as a CSP is to have one variable per cell, so 81 variables total, and for each row, horizontal and block an &lt;em&gt;all-different&lt;/em&gt; constraint. Sudokus can also be generalized to NxN grids; e.g., 25x25 sudoku has cells which can be filled in with a value between 1 and 25 and 25 rows, columns, and blocks.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;the-solver&#34;&gt;The solver&lt;/h2&gt;&lt;p&gt;There are a few different kinds of solvers for CSPs, the kind I have built is a constructive solver which has the ability to enumerate all solutions to a CSP, and similarly, guarantee that no solutions exist when that is the case. Here&amp;rsquo;s a quick rundown in bullet-form of how it works:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The core algorithm is building a tree that searches for a solution by making decisions, and after making a decision seeing if a solution still exists.&lt;/li&gt;&lt;li&gt;A decision is basically of the form &amp;ldquo;I think I can put the first queen on row #2&amp;rdquo;. Once a decision is made it holds until the solver either finds a solution that includes that decision, or proves that no solution exists with that decision.&lt;/li&gt;&lt;li&gt;When the solver does learn that no solutions exist based on an earlier decision, it backtracks; i.e., undoes that decision.&lt;/li&gt;&lt;li&gt;This algorithm will thus try all possibilities until an asnwer is found, or no answer is proven to exist.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;TL;DR: the algo is basically just DFS (depth first search). Easy peasy, right?&lt;/p&gt;&lt;p&gt;&amp;hellip; wait, the number of possible states gets pretty obscene, doesn&amp;rsquo;t it? Sure does! So how do we have any hope of finding a solution? Well, we&amp;rsquo;ll need to be smart about how we explore the possible states (aka the search space):&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;When making a decision we can be more careful about what that decision is. For example, we may want to pick a queen that only has two possible spots where it won&amp;rsquo;t be attacked. This is an example of &lt;em&gt;first fail&lt;/em&gt; variable ordering heuristic.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;After making a decision, like &amp;ldquo;first queen goes on row #2&amp;rdquo;, we can decude that placing other queens on the same row doesn&amp;rsquo;t make any sense, and not attempt doing so. This is an example of &lt;em&gt;constraint propagation&lt;/em&gt;. Conveniently, this makes it easier for us to choose the next queen (see previous bullet point).&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;We can get smart about recovering from failing to find a solution. An example of this is &lt;em&gt;backjumping&lt;/em&gt;, where rather than going back to the latest decision, i.e., simply &lt;em&gt;backtracking&lt;/em&gt;, we jump further back and skip parts of the search tree that are guaranteed to not have a solution.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I&amp;rsquo;ll cover these in separate posts, but for now hopefully this gives you an idea how the simplistic-looking DFS algorithm can be extended and handle traversing rather obscene search spaces.&lt;/p&gt;&lt;h3 id=&#34;why-its-hard-to-build&#34;&gt;Why it&amp;rsquo;s hard to build&lt;/h3&gt;&lt;p&gt;In short, because the search space is huge, optimization becomes critical. This applies to just about every step of the search process, from efficiently representing the problem and the search state, to efficiently updating the state and auxillary data structures, to quickly and correctly applying the techniques above, like constraint propagation and backjumping. I&amp;rsquo;ll cover these in more detail later as I intend to write some posts about different kinds of &lt;em&gt;all-different&lt;/em&gt; constraints, constraint propagation in general, and backjumping vs backtracking.&lt;/p&gt;&lt;h3 id=&#34;where-it-is-today&#34;&gt;Where it is today&lt;/h3&gt;&lt;p&gt;The solver runs on an E2 instance in Google Cloud, on freebie quota. As such, there are significant limitations to the CPU and RAM, yet it is still able to easily chew through most 15x15 crosswords and generalized NxN sudokus, up to 36x36 in size. The solver itself also supports finding &lt;em&gt;the best solution&lt;/em&gt; and not just any solution, which requires providing an &lt;em&gt;objective function&lt;/em&gt; as part of the problem, however this isn&amp;rsquo;t yet surfaced through the site. An example application would be picking words for a crossword that are more common and avoiding other words, like abbreviations. There are also other, &amp;ldquo;infrastructural&amp;rdquo; improvements, which I may get to in the future. I may also look to apply the solver to a new class of problems, but I&amp;rsquo;m not sure what those will be yet.&lt;/p&gt;&lt;p&gt;With that, I&amp;rsquo;ll close this post out with a quick plug to my solver for &lt;a href=&#34;https://dawnofthe.dad/ndoku&#34;&gt;NxN sudoku&lt;/a&gt; where you can see that by applying the techniques outlined here the solver is able to find a solution for a problem with a search space larger than a googol in a few seconds.&lt;/p&gt;</description>
     </item>
   
     <item>
       <title>Why tho</title>
       <link>https://blog.dawnofthe.dad/posts/why-tho/</link>
       <pubDate>Sat, 26 Aug 2023 21:00:03 +0000</pubDate>
       
       <guid>https://blog.dawnofthe.dad/posts/why-tho/</guid>
       <description>&lt;p&gt;&lt;img src=&#34;https://blog.dawnofthe.dad/y-tho.jpg&#34; alt=&#34;Oblig meme&#34;&gt;&lt;/p&gt;&lt;h2 id=&#34;what-and-why&#34;&gt;What and why?&lt;/h2&gt;&lt;p&gt;First, the &lt;strong&gt;what&lt;/strong&gt;: &lt;a href=&#34;https://dawnofthe.dad&#34;&gt;Dawn of the Dad&lt;/a&gt; is basically the 2 solvers: one for &lt;a href=&#34;https://dawnofthe.dad/sudoku&#34;&gt;sudoku&lt;/a&gt;, and another for &lt;a href=&#34;https://dawnofthe.dad/crossword&#34;&gt;building crosswords&lt;/a&gt;. The first is largely complete, so most of my time now is dedicated to beefing up the crossword builder.&lt;/p&gt;&lt;p&gt;Now the &lt;strong&gt;why&lt;/strong&gt;: why build the site and why ramble in this blog?&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;The site is my excuse to write some code, both to stay sharp and because I like doing it, solve some algorithmically interesting problems, and revisit some of the neat things I&amp;rsquo;ve learned about back in grad school. Originally, this spun off as a yet-another-rewrite of a general-purpose &lt;a href=&#34;https://en.wikipedia.org/wiki/Constraint_satisfaction_problem&#34;&gt;CSP&lt;/a&gt; solver, which then led to adding fairly ad hoc visualization, which led to building a web server, hacking up a websocket protocol, glueing it all together and finally hosting it on Google Cloud.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The blog is largely meant to capture some of the interesting things I&amp;rsquo;ve learned along the way, like tuning / optimizing the solver and dealing with the hug of death I got from that one time my site briefly hit the front page of &lt;a href=&#34;https://news.ycombinator.com/news&#34;&gt;Hacker News&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&#34;post-frequency&#34;&gt;Post frequency&lt;/h2&gt;&lt;p&gt;I&amp;rsquo;ll probably end up writing a bunch of posts relatively quickly at first, as I&amp;rsquo;m catching up on a year&amp;rsquo;s worth of potentially interesting things to write down, before I forget them. Once I do, I expect things to slow down a fair bit.&lt;/p&gt;</description>
     </item>
   
 </channel>
</rss>
