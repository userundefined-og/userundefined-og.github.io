<!doctype html>

<html lang="en-us">

<head>
  <title>Search Algo in Go - Blog of the Dad</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="The HTML5 Herald" />
<meta name="author" content="Andrei" /><meta property="og:title" content="Search Algo in Go" />
<meta property="og:description" content="My previous couple of posts talked about what the solver does (solves CSPs), how to model a problem as a CSP, and how the search tree is built as the solver searches for a solution. In this post I will expand on the details of search by outlining the key data structures and bits of code. The backend is written in Go lang, and so are all of the code snippets here." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.dawnofthe.dad/posts/search-algo-in-go/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-03T10:24:10-07:00" />
<meta property="article:modified_time" content="2023-09-03T10:24:10-07:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Search Algo in Go"/>
<meta name="twitter:description" content="My previous couple of posts talked about what the solver does (solves CSPs), how to model a problem as a CSP, and how the search tree is built as the solver searches for a solution. In this post I will expand on the details of search by outlining the key data structures and bits of code. The backend is written in Go lang, and so are all of the code snippets here."/>

<meta name="generator" content="Hugo 0.117.0">
    
    <script src="/js/mathjax-config.js" defer></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://blog.dawnofthe.dad/fontawesome/css/all.min.css" />
  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  
  
  <link rel="stylesheet" type="text/css" href="/css/styles.css" />
</head>

<body>
  <div id="container">
    <header>
      
      <h1>
        <a href="/">Blog of the Dad</a>
      </h1>

      <ul id="social-media">
             <li>
               <a href="https://twitter.com/userundefinedrd" title="Twitter">
               <i class="fab fa-twitter fa-lg"></i>
               </a>
             </li>
      </ul>
      
      <p><em>Donâ€™t eat me. I have a wife and kids. Eat them.</em></p>
      
    </header>

    
<nav>
    <ul>
        
    </ul>
</nav>


    <main>




<article>

    <h1>Search Algo in Go</h1>

    
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2023-09-03T10:24:10-07:00">Sep 3, 2023</time>
        </li>
        
        

        
        <li>
            <em>
                
                    
                    <a href="/tags/algorithms">#Algorithms</a>
                
                    , 
                    <a href="/tags/constructive-search">#Constructive search</a>
                
                    , 
                    <a href="/tags/go">#Go</a>
                
            </em>
        </li>
        

        <li>4 minute read</li>
    </ul>
</aside>

    

    
      

    

    <p>My previous couple of posts talked about <a href="https://blog.dawnofthe.dad/posts/solver-intro/">what the solver does (solves CSPs)</a>, <a href="https://blog.dawnofthe.dad/posts/solver-basics/">how to model a problem as a CSP, and how the search tree is built</a> as the solver searches for a solution. In this post I will expand on the details of search by outlining the key data structures and bits of code. The backend is written in <a href="https://go.dev">Go lang</a>, and so are all of the code snippets here.</p>
<h2 id="nodes-in-the-search-tree">Nodes in the search tree</h2>
<p>We&rsquo;ll be building a search tree, which is composed of nodes. We&rsquo;ll also need to track a couple of things as we build the search tree. Here they are:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">nodeState</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> (
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">freshNode</span> <span style="color:#a6e22e">nodeState</span> = <span style="color:#66d9ef">iota</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">solutionFound</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">assignmentTried</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">unassignmentTried</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">decision</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">variable</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">model</span>.<span style="color:#a6e22e">Variable</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">value</span>    <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// When true it means variable = value, when false it means variable != value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">valueAssigned</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">node</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">parent</span>      <span style="color:#f92672">*</span><span style="color:#a6e22e">node</span> <span style="color:#75715e">// nil at root
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">state</span>       <span style="color:#a6e22e">nodeState</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">decision</span>    <span style="color:#f92672">*</span><span style="color:#a6e22e">decision</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>node</code> struct above lets us:</p>
<ul>
<li>Keep track of the node&rsquo;s <code>parent</code>, so we can easily go back up the tree when backtracking,</li>
<li>Keep track of the <code>nodeState</code>, which we&rsquo;ll use to tell us what to do when we visit or revisit a node,</li>
<li>Keep track of the <code>decision</code> we made at this node, which we can use to evaluate constraints, and, when all variables are assigned, to tell us what the full solution is, by walking backwards up the tree and collapsing all the decisions that led to the solution into a full assignment of values to variables.</li>
</ul>
<h2 id="building-the-search-tree">Building the search tree</h2>
<p>My code has two key functions: <code>Run()</code>, which is the top-level function called by external clients, like the web server, and <code>step()</code>, which is a single step in the search tree where we look at the current <code>node.state</code> and decide what to do next. Here they are, along with the <code>Search</code> struct that they belong to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Search</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">root</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">current</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Search</span>) <span style="color:#a6e22e">Run</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">done</span>, <span style="color:#a6e22e">solution</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">step</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">done</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">solution</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Search</span>) <span style="color:#a6e22e">step</span>() (<span style="color:#66d9ef">bool</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">Solution</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">state</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">freshNode</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">decision</span> = <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">makeNextDecision</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">decision</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Found a solution.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">state</span> = <span style="color:#a6e22e">solutionFound</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>, <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Assignments</span>()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">state</span> = <span style="color:#a6e22e">assignmentTried</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">current</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">node</span>{<span style="color:#a6e22e">parent</span>: <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">current</span>}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">solutionFound</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// We can get here if we&#39;re resuming from a previous solution. We&#39;ll resume
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// by backtracking out of this node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">current</span> = <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">parent</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">assignmentTried</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">decision</span>.<span style="color:#a6e22e">valueAssigned</span> = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">state</span> = <span style="color:#a6e22e">unassignmentTried</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">current</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">node</span>{<span style="color:#a6e22e">parent</span>: <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">current</span>}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">unassignmentTried</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">current</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">root</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// We exhausted the search space, no solutions are left.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">current</span> = <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">parent</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see, <code>Run()</code> is exceptionally straight-forward - it simply keeps calling <code>step()</code> until <code>step()</code> says it is <code>done</code>, which happens either because a solution has been found, or the entire search space has been exhausted, and no more solutions as exist. On the other hand, <code>step()</code> is a bit more complicated - it looks at the state that the current node is in and:</p>
<ul>
<li>For <code>freshNode</code> search makes a decision; if that&rsquo;s <code>nil</code> then we have a solution, otherwise we create a child node and move into it.</li>
<li>For <code>solutionFound</code> search simply backtracks, so that search can continue to the next solution.</li>
<li>For <code>assignmentTried</code> search flips the assignment to <em>unassignment</em> (e.g., if the assignment was \(A = 5\) it&rsquo;ll become \(A \ne 5\)). This is where the binary nature of the search tree comes from, that I mentioned in my other posts.</li>
<li>For <code>unassignmentTried</code> search knows that at this point no more solutions can be found in the current subtree and it needs to backtrack. If search detects that it is already at the root node, that means it has nowhere to backtrack to and there are no more solutions at all.</li>
</ul>
<p>And that&rsquo;s the heart of the constructive search algorithm. A few important things are left out for now though, which make what is essentially just DFS effective. I&rsquo;ll cover these later, but I will touch on them briefly here:</p>
<ul>
<li>Heuristics and decision making in general are alluded to with <code>s.makeNextDecision()</code>, but not fleshed out. This part delegates the heavy lifting to the variable and value ordering heuristics, and while those can be as simple as lexicographic, can get relatively sophisticated.</li>
<li>Applying <em>constraint propagation</em> after making decisions, and tracking its results, so that they may be retracted upon backtracking. This will allow search to quickly eliminate parts of search space that are guaranteed to not contain solutions.</li>
<li>Supporting <em>backjumping</em> rather than just simple backtracking.</li>
</ul>

</article>


<section class="post-nav">
    <ul>
        <li>
        
            <a href="https://blog.dawnofthe.dad/posts/solver-basics/"><i class="fa fa-chevron-circle-left"></i> Solver basics</a>
        
        </li>
        <li>
        
        </li>
    </ul>
</section>
  
    
    
  





</main>
    <footer>
        <ul>
            <li>
                <h6>
                    Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a></h6>
            </li>
            
            
        </ul>
    </footer>
</div>
<script src="/js/scripts.js"></script>

  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WS2FCBYJLF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WS2FCBYJLF', { 'anonymize_ip': false });
}
</script>



</body>

</html>

