<!doctype html>

<html lang="en-us">

<head>
  <title>Solver intro - Blog of the Dad</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="The HTML5 Herald" />
<meta name="author" content="Andrei" /><meta property="og:title" content="Solver intro" />
<meta property="og:description" content="The underlying general purpose solver is the most interesting and most complex part of the backend; it&rsquo;s also the thing I have now rewritten 3 times for various reasons. So I&rsquo;m going to talk about that a bit: what it does, why it is interesting and challenging to build, and where it is at today." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.dawnofthe.dad/posts/solver-intro/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-26T22:43:00+00:00" />
<meta property="article:modified_time" content="2023-08-26T22:43:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Solver intro"/>
<meta name="twitter:description" content="The underlying general purpose solver is the most interesting and most complex part of the backend; it&rsquo;s also the thing I have now rewritten 3 times for various reasons. So I&rsquo;m going to talk about that a bit: what it does, why it is interesting and challenging to build, and where it is at today."/>

<meta name="generator" content="Hugo 0.117.0">
    
    <script src="/js/mathjax-config.js" defer></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://blog.dawnofthe.dad/fontawesome/css/all.min.css" />
  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  
  
  <link rel="stylesheet" type="text/css" href="/css/styles.css" />
</head>

<body>
  <div id="container">
    <header>
      
      <h1>
        <a href="/">Blog of the Dad</a>
      </h1>

      <ul id="social-media">
             <li>
               <a href="https://twitter.com/userundefinedrd" title="Twitter">
               <i class="fab fa-twitter fa-lg"></i>
               </a>
             </li>
      </ul>
      
      <p><em>Donâ€™t eat me. I have a wife and kids. Eat them.</em></p>
      
    </header>

    
<nav>
    <ul>
        
    </ul>
</nav>


    <main>




<article>

    <h1>Solver intro</h1>

    
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2023-08-26T22:43:00Z">Aug 26, 2023</time>
        </li>
        
        

        
        <li>
            <em>
                
                    
                    <a href="/tags/algorithms">#Algorithms</a>
                
                    , 
                    <a href="/tags/constructive-search">#Constructive search</a>
                
            </em>
        </li>
        

        <li>5 minute read</li>
    </ul>
</aside>

    

    
      

    

    <p>The underlying general purpose solver is the most interesting and most complex part of the backend; it&rsquo;s also the thing I have now rewritten 3 times for various reasons. So I&rsquo;m going to talk about that a bit: what it does, why it is interesting and challenging to build, and where it is at today.</p>
<h2 id="the-problem">The problem</h2>
<p>The solver is designed to solve <a href="https://en.wikipedia.org/wiki/Constraint_satisfaction_problem">constraint satisfaction problems</a>; aka CSPs. These problems are generally expressed by some number of variables with constraints on these variables. Here are a couple of examples of CSPs:</p>
<ul>
<li>
<p><strong>N-queens problem</strong>: for an NxN chess board, how can one position the queens such that none of them are attacking each other? A common way of expressing this as a CSP is to have one variable per column (because having more than one queen per column clearly violates the requirement that queens should not attack each other) and constraints that ensure that no two queens share a row, or a diagonal.</p>
</li>
<li>
<p><strong>Sudoku</strong>: for a 9x9 grid, how can one fill in the grid with digits from 1 to 9 such that no row, column, or block has the digit appear more than once? A way to model this as a CSP is to have one variable per cell, so 81 variables total, and for each row, horizontal and block an <em>all-different</em> constraint. Sudokus can also be generalized to NxN grids; e.g., 25x25 sudoku has cells which can be filled in with a value between 1 and 25 and 25 rows, columns, and blocks.</p>
</li>
</ul>
<h2 id="the-solver">The solver</h2>
<p>There are a few different kinds of solvers for CSPs, the kind I have built is a constructive solver which has the ability to enumerate all solutions to a CSP, and similarly, guarantee that no solutions exist when that is the case. Here&rsquo;s a quick rundown in bullet-form of how it works:</p>
<ul>
<li>The core algorithm is building a tree that searches for a solution by making decisions, and after making a decision seeing if a solution still exists.</li>
<li>A decision is basically of the form &ldquo;I think I can put the first queen on row #2&rdquo;. Once a decision is made it holds until the solver either finds a solution that includes that decision, or proves that no solution exists with that decision.</li>
<li>When the solver does learn that no solutions exist based on an earlier decision, it backtracks; i.e., undoes that decision.</li>
<li>This algorithm will thus try all possibilities until an asnwer is found, or no answer is proven to exist.</li>
</ul>
<p>TL;DR: the algo is basically just DFS (depth first search). Easy peasy, right?</p>
<p>&hellip; wait, the number of possible states gets pretty obscene, doesn&rsquo;t it? Sure does! So how do we have any hope of finding a solution? Well, we&rsquo;ll need to be smart about how we explore the possible states (aka the search space):</p>
<ul>
<li>
<p>When making a decision we can be more careful about what that decision is. For example, we may want to pick a queen that only has two possible spots where it won&rsquo;t be attacked. This is an example of <em>first fail</em> variable ordering heuristic.</p>
</li>
<li>
<p>After making a decision, like &ldquo;first queen goes on row #2&rdquo;, we can decude that placing other queens on the same row doesn&rsquo;t make any sense, and not attempt doing so. This is an example of <em>constraint propagation</em>. Conveniently, this makes it easier for us to choose the next queen (see previous bullet point).</p>
</li>
<li>
<p>We can get smart about recovering from failing to find a solution. An example of this is <em>backjumping</em>, where rather than going back to the latest decision, i.e., simply <em>backtracking</em>, we jump further back and skip parts of the search tree that are guaranteed to not have a solution.</p>
</li>
</ul>
<p>I&rsquo;ll cover these in separate posts, but for now hopefully this gives you an idea how the simplistic-looking DFS algorithm can be extended and handle traversing rather obscene search spaces.</p>
<h3 id="why-its-hard-to-build">Why it&rsquo;s hard to build</h3>
<p>In short, because the search space is huge, optimization becomes critical. This applies to just about every step of the search process, from efficiently representing the problem and the search state, to efficiently updating the state and auxillary data structures, to quickly and correctly applying the techniques above, like constraint propagation and backjumping. I&rsquo;ll cover these in more detail later as I intend to write some posts about different kinds of <em>all-different</em> constraints, constraint propagation in general, and backjumping vs backtracking.</p>
<h3 id="where-it-is-today">Where it is today</h3>
<p>The solver runs on an E2 instance in Google Cloud, on freebie quota. As such, there are significant limitations to the CPU and RAM, yet it is still able to easily chew through most 15x15 crosswords and generalized NxN sudokus, up to 36x36 in size. The solver itself also supports finding <em>the best solution</em> and not just any solution, which requires providing an <em>objective function</em> as part of the problem, however this isn&rsquo;t yet surfaced through the site. An example application would be picking words for a crossword that are more common and avoiding other words, like abbreviations. There are also other, &ldquo;infrastructural&rdquo; improvements, which I may get to in the future. I may also look to apply the solver to a new class of problems, but I&rsquo;m not sure what those will be yet.</p>
<p>With that, I&rsquo;ll close this post out with a quick plug for my solver for <a href="https://dawnofthe.dad/ndoku">NxN sudoku</a> where you can see that by applying the techniques mentioned here the solver is able to find a solution for a 25x25 sudoku in a couple of seconds. In contrast, with a pure brute-force algorithm, we may need to consider an enormous number of states: $$(25 \times 25) ^ {25} = 7.889 \times 10^{69}$$</p>

</article>


<section class="post-nav">
    <ul>
        <li>
        
            <a href="https://blog.dawnofthe.dad/posts/why-tho/"><i class="fa fa-chevron-circle-left"></i> Why tho</a>
        
        </li>
        <li>
        
        </li>
    </ul>
</section>
  
    
    
  





</main>
    <footer>
        <ul>
            <li>
                <h6>
                    Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
                    <a href="https://blog.dawnofthe.dad/index.xml">Subscribe </a></h6>
            </li>
            
            
        </ul>
    </footer>
</div>
<script src="/js/scripts.js"></script>

  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WS2FCBYJLF"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WS2FCBYJLF', { 'anonymize_ip': false });
}
</script>



</body>

</html>

