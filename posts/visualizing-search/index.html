<!doctype html><html lang=en-us><head><title>Visualizing Search - Blog of the Dad</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="The HTML5 Herald"><meta name=author content="Andrei"><meta property="og:title" content="Visualizing Search"><meta property="og:description" content="Part of the appeal of building a solver for the fourth time (?!) for me is that it&rsquo;s fun to watch how it solves the problem. While it&rsquo;s possible and quick to hack something up on command line, the results aren&rsquo;t that pretty and can&rsquo;t be easily shared. In this post I&rsquo;ll talk about building a frontend that talks to the backend via websockets and produces an animated visualization of how the search is solving the problem.
The scope of this post, and my initial frontend, is generalized NxN sudokus, and this first iteration of the frontend focused on largely non-interactive visualization. You can try it out for yourself online. I&rsquo;ll talk about building up more interactive solvers for regular sudoku and crosswords separately."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.dawnofthe.dad/posts/visualizing-search/"><meta property="og:image" content="https://blog.dawnofthe.dad/ndoku-in-progress.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-09T12:50:58-07:00"><meta property="article:modified_time" content="2023-09-09T12:50:58-07:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.dawnofthe.dad/ndoku-in-progress.png"><meta name=twitter:title content="Visualizing Search"><meta name=twitter:description content="Part of the appeal of building a solver for the fourth time (?!) for me is that it&rsquo;s fun to watch how it solves the problem. While it&rsquo;s possible and quick to hack something up on command line, the results aren&rsquo;t that pretty and can&rsquo;t be easily shared. In this post I&rsquo;ll talk about building a frontend that talks to the backend via websockets and produces an animated visualization of how the search is solving the problem.
The scope of this post, and my initial frontend, is generalized NxN sudokus, and this first iteration of the frontend focused on largely non-interactive visualization. You can try it out for yourself online. I&rsquo;ll talk about building up more interactive solvers for regular sudoku and crosswords separately."><meta name=generator content="Hugo 0.117.0"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=/android-chrome-192x192.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=apple-mobile-web-app-title content="Dawn of the Dad"><meta name=application-name content="Dawn of the Dad"><meta name=msapplication-TileColor content="#da532c"><meta name=msapplication-TileImage content="/mstile-144x144.png"><meta name=theme-color content="#ffffff"><script src=/js/mathjax-config.js defer></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin=anonymous><link rel=stylesheet href=https://blog.dawnofthe.dad/fontawesome/css/all.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"><link rel=stylesheet type=text/css href=/css/styles.css></head><body><div id=container><header><h1><a href=/>Blog of the Dad</a></h1><ul id=social-media><li><a href=https://twitter.com/userundefinedrd title=Twitter><i class="fab fa-twitter fa-lg"></i></a></li><li><a href=https://reddit.com/u/userundefined title=Reddit><i class="fab fa-reddit-alien fa-lg"></i></a></li></ul><p><em>Donâ€™t eat me. I have a wife and kids. Eat them.</em></p></header><nav><ul></ul></nav><main><article><h1>Visualizing Search</h1><aside><ul><li><time class=post-date datetime=2023-09-09T12:50:58-07:00>Sep 9, 2023</time></li><li><em><a href=/tags/backend>#Backend</a>
,
<a href=/tags/constructive-search>#Constructive search</a>
,
<a href=/tags/frontend>#Frontend</a>
,
<a href=/tags/visualization>#Visualization</a></em></li><li>10 minute read</li></ul></aside><div class=featured_image><a href=https://blog.dawnofthe.dad/posts/visualizing-search/ title="Visualizing Search"><img src=/ndoku-in-progress.png></a></div><p>Part of the appeal of building a solver for the fourth time (?!) for me is that it&rsquo;s fun to watch how it solves the problem. While it&rsquo;s possible and quick to hack something up on command line, the results aren&rsquo;t that pretty and can&rsquo;t be easily shared. In this post I&rsquo;ll talk about building a frontend that talks to the backend via websockets and produces an animated visualization of how the search is solving the problem.</p><p>The scope of this post, and my initial frontend, is generalized NxN sudokus, and this first iteration of the frontend focused on largely non-interactive visualization. You can <a href=https://dawnofthe.dad/ndoku>try it out for yourself online</a>. I&rsquo;ll talk about building up more interactive solvers for regular <a href=https://dawnofthe.dad/sudoku>sudoku</a> and <a href=https://dawnofthe.dad/crossword>crosswords</a> separately.</p><h2 id=a-little-background>A little background</h2><p>I rewrote the solver a few times, for various reasons, but before this latest rewrite only my very first solver had any kind of visualization. It was built during my grad studies and, largely due to my familiarity with Java at the time, was built with a crude, but useful Java UX. So when I felt the itch to write some code, building up a UX this time around was high on the list of things to do. This time my language of choice for the solver was Go, and with Go being an awesome language for servers (web and otherwise), and my <strong>very</strong> dated front-end web dev experience, it felt like building up the solver in Go as a backend and having a JS web frontend would be the way to go.</p><h2 id=basic-flow>Basic flow</h2><p>The basic flow between the user, browser and the backend is this:<div class=mermaid>sequenceDiagram
participant User
participant Browser
participant Backend
User->>Browser: Presses "Next solution" button
Browser->>Backend: Start solving
loop Solving
Backend->>Browser: State updates every 30ms until solved
end</div></p><p>This doesn&rsquo;t allow user to do much beyond hitting the button and watching the solver do its thing, but this is sufficient for trying out things like different <a href=https://blog.dawnofthe.dad/posts/heuristics/>heuristics</a> and seeing how they impact search. For example, you can click through the following links to see how 5x5 sudoku looks like with <a href=https://dawnofthe.dad/ndoku?lex>lexicographic ordering</a>, <a href=https://dawnofthe.dad/ndoku?fast>random ordering</a> or <a href=https://dawnofthe.dad/ndoku>spiral ordering</a>; that last one was primarily added for fun and because lexicographic ordering on sudokus is surprisingly fast, so I wanted to make the solver do more work on purpose.</p><h2 id=backend-and-frontend>Backend and frontend</h2><p>Backend&rsquo;s primary job is to solve problems thrown at it, but, to keep things simple and not add another dependency, it also happens to be a basic web server and serves up the largely static web pages, such as the initial screen for the NxN sudoku that the user sees. More importantly though, the backend also allows the frontend to connect to it via websockets, which are used to send state updates and basic control messages between the frontend and the backend. The page served by the backend has two key elements: the canvas where we will draw the state, and the button that lets the user kick off the solving process.</p><p>The frontend is in JS and is quite basic. It does the following:</p><ul><li>Waits for the user to press the button, and once pressed connects via a websocket to the backend. The websocket is kept open until either the user leaves the page or no more solutions can be found.</li><li>For each message from the backend it will interpret the message per the rudimentary protocol, described below, and handle it.</li><li>Most messages are state updates, and so JS will update the state of the sudoku board, represented by the large canvas element. This is the &ldquo;Solving&rdquo; loop in the sequence diagram above.</li><li>There are a couple of other messages that the backend can send - one when a solution has been found and the user can search for more by hitting the button again, and another when no more solutions exist.</li></ul><p>By the way, while I&rsquo;m still waffling as to whether open-source the backend, JS frontend code is effectively open-sourced in that it is unobfuscated and easily readable. If you&rsquo;d like, you can check it out <a href=https://dawnofthe.dad/static/js/ndoku.js>here</a>.</p><h2 id=websockets-and-the-protocol>Websockets and the protocol</h2><p>Since the bulk of communication between the backend and the frontend will be state updates that is the most interesting bit of the protocol, while the rest is truly simple and borderline silly. Let&rsquo;s do these basic control messages first to get them out of the way; there are two categories: frontend telling backend it wants the next solution, and backend telling the frontend something <em>other</em> than a state update. Since the frontend doesn&rsquo;t do anything other than says &ldquo;Give me next solution&rdquo; the protocol is <em>literally</em> that any message from the frontend to the backend will make the solver look for the next solution. The backend to frontend messages are almost as simple, as there are only two mentioned above, and they&rsquo;re sent as strings. Could I do something shorter/smarter? Yes. Was it worth the effort? <a href=https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it>YAGNI</a> says &ldquo;nah&rdquo; &mldr; at least until something breaks horribly and I&rsquo;ll be forced to fix this.</p><p>State updates are more interesting - let&rsquo;s see what the solver knows about the current state and how that can be passed along as part of the protocol:</p><ul><li>The solver knows the state of each cell in the NxN sudoku (represented internally by a variable). Naturally, there are NxN cells.</li><li>A given cell can either be assigned a value, from 1 to N, or it can be unassigned.</li><li>In my initial implementation that was basically what was sent through the websocket - either 1 through N, or 0 for unassigned state&mldr; but the solver knows something else about unassigned cells, namely how many values are in that variable&rsquo;s live domain (remember <a href=https://blog.dawnofthe.dad/posts/constraint-propagation/>constraint propagation</a>?), so it&rsquo;d be cool if we could show that on the frontend, too. We can do that fairly easily - for each cell that is not assigned we can use values N+1 through 2*N to pass this info on to the frontend. And that&rsquo;s exactly what the protocol does.</li></ul><p>TL;DR state updates are just a message with N*N bytes, and each byte mapped to values / remaining-live-values as per above.</p><p>A couple of quick notes:</p><ul><li>Could the state updates be compressed? Yes, definitely. For now though, I am looking for ways to shed CPU cycles where possible, and between that and YAGNI it seemed unnecessary to apply compression on the server followed by decompression on the client. I may change my mind as this lack of compression is in part why the online version of NxN sudoku solver is limited to 36x36 sudokus, while in practice my E2 GCE instance could likely handle at least 64x64 without blowing up.</li><li>Won&rsquo;t this protocol break for N > 121? Yup&mldr; but with the current implementation 100x100 already takes close to an hour on my rather dated machine, so redesigning the protocol for grids 144x144 and larger isn&rsquo;t a priority now.</li></ul><h3 id=example-message>Example message</h3><p>Let&rsquo;s take a quick look at the classic 9x9 sudoku. If you want to follow along you can open <a href="https://dawnofthe.dad/ndoku?n=3&amp;lex">this link</a>, open DevTools and head over to the network tab, assuming that you&rsquo;re in Chrome. After you hit &ldquo;Next solution&rdquo;, you&rsquo;ll see the grid get populated (by the way, for 9x9 grids the solver is throttled so that you can see every step of the solution; this is on purpose). On the DevTools network tab you&rsquo;ll also note a bunch of messages sent over the websocket, as shown below. We&rsquo;ll examine one of them.</p><p><img src=/sudoku-protocol-example.png alt="Sudoku protocol example"></p><p>Here you can see how the first message to the server was just an empty string - as I mentioned above any message will trigger a solve, and I just happen to be sending an empty string to do so. That&rsquo;s not too interesting though, so we&rsquo;ll grab the 4th binary message <strong>from the server</strong>. Let&rsquo;s copy it as hex. You should get this:</p><pre tabindex=0><code>0102030f0f0f0f0f0f0f0f0f1212121212120f0f0f121212121212111111121212121212111111121212121212111111121212121212111111121212121212111111121212121212111111121212121212
</code></pre><p>As this is hex each two characters represent a value of a cell. Let&rsquo;s look at the first few cells:</p><pre tabindex=0><code>0x01
0x02
0x03
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x0f
0x12
</code></pre><p>So what are we looking at? The backend assigns variables to values in lexicographic order, as we asked it to. The first message will be just the initial, empty grid, so after 4 messages we should get variables for cells (0, 0), (0, 1) and (0, 2) assigned; in other words, the first three squares in the top row. And that&rsquo;s exactly what we see above, they are assigned to 1, 2 and 3, respectively.</p><p>The next few columns are a bit more interesting - we see a whole bunch of <code>0x0f</code> values. Remember how the protocol uses values beyond N to represent that variables are unassigned and have some number of live values left? This is telling us that we have <code>0x0f - 9 = 6</code> live values left in the domain of these variables. There are 9 of these:</p><ul><li>The first 6 cover the remainder of the row; i.e., cells (0, 3) through (0, 8).</li><li>The next three values will cover the cells on row 1 (zero index based) of the 3x3 box that the solver has just populated; i.e., cells (1, 0), (1, 1) and (1, 2), and they too, only have 6 live values.</li></ul><p>Finally, we get to cell (1, 3) which is not affected by current assignments and has all 9 live values (<code>0x12 - 9 = 9</code>).</p><p>The rest of the message follows the same pattern as the above, as do all the other messages that the backend sends our way. Finally, the <strong>very last message</strong> also has the somewhat lazy plain-text string stating that more solutions are available, which I&rsquo;ve also mentioned above.</p><h2 id=search-state-visualization>Search state visualization</h2><p>With the protocol defined and telling us what is being sent over the websocket, all that&rsquo;s left is to render the sudoku. It&rsquo;s easiest to describe this by walking through some code, so here&rsquo;s the key bit:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// Variable &#34;edge&#34; refers to the size of the sudoku;
</span></span></span><span style=display:flex><span><span style=color:#75715e>// i.e. the &#34;N&#34; in NxN.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>y</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>edge</span>; <span style=color:#a6e22e>y</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>edge</span>; <span style=color:#a6e22e>x</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>idx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>edge</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>view</span>.<span style=color:#a6e22e>getUint8</span>(<span style=color:#a6e22e>idx</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>value</span> <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>edge</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillStyle</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>unassignedColors</span>[<span style=color:#a6e22e>value</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>edge</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillStyle</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>valueColors</span>[<span style=color:#a6e22e>value</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>fillRect</span>(<span style=color:#a6e22e>x</span><span style=color:#f92672>*</span><span style=color:#a6e22e>edgeLen</span>, <span style=color:#a6e22e>y</span><span style=color:#f92672>*</span><span style=color:#a6e22e>edgeLen</span>, <span style=color:#a6e22e>edgeLen</span>, <span style=color:#a6e22e>edgeLen</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The two for-loops just go through the grid and give us an index into the <code>view</code>, which is just a JS <code>DataView</code>. That&rsquo;s the value of that particular cell, and its meaning it mentioned in the protocol section above. Now that we have it, we know whether to render that as a set cell, or one that still hasn&rsquo;t been set and has live values in its domain - that&rsquo;s the if statement. We look up the color, and set that cell to that color.</p><p>With regards to the colors for assigned and unassigned variables (i.e., <code>valueColors</code> and <code>unassignedColors</code> in the code above, respectively), if you look at the source code a bit higher, you&rsquo;ll see this bit:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>valueColors</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>generateHslaColors</span>(<span style=color:#ae81ff>70</span>, <span style=color:#ae81ff>60</span>, <span style=color:#a6e22e>edge</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>unassignedColors</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>generateGrayscaleColors</span>(<span style=color:#ae81ff>30</span>, <span style=color:#a6e22e>edge</span>);
</span></span></code></pre></div><p>That basically creates a slew of &ldquo;rainbow&rdquo; colors mapping red to low values and violet to high values for variables / cells that are set, and grayscale colors for unset variables, with white meaning all live values are possible and dark gray meaning very few live values remain. So what we&rsquo;ll see is that any given row, horizontal or block in the NxN sudoku has unique &ldquo;rainbow&rdquo; colors, and as search gets deeper and deeper down the search tree the unassigned variables turn darker and darker as <a href=https://blog.dawnofthe.dad/posts/constraint-propagation/>constraint propagation</a> eliminates impossible values from live domains of unassigned variables.</p><p>And that&rsquo;s it! Hopefully this helps you understand how visualization works, what the image at the top of this post is about, and gives you some ideas how you might go about visualizing interesting algos.</p></article><script type=application/javascript src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>var darkOrLight="light",config;window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches&&(darkOrLight="dark"),config={startOnLoad:!0,theme:darkOrLight},mermaid.initialize(config)</script><section class=post-nav><ul><li><a href=https://blog.dawnofthe.dad/posts/heuristics/><i class="fa fa-chevron-circle-left"></i> Heuristics</a></li><li></li></ul></section></main><footer><ul><li><h6>Rendered by <a href=https://gohugo.io title=Hugo>Hugo</a> and based on a fork of the <a href=https://themes.gohugo.io/themes/hugo-kiera/>Kiera theme</a></h6></li></ul></footer></div><script src=/%20js/scripts.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WS2FCBYJLF"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WS2FCBYJLF",{anonymize_ip:!1})}</script></body></html>